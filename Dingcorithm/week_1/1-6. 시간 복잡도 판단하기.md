# 시간 복잡도란?
- "입력값에 비해 얼마나 일을 수행하는가?"
- 시간이 적게 걸리는 알고리즘을 좋아한다.
	- 입력 값이 늘어나도 시간이 덜 늘어나는 알고리즘을 선호한다.


## 예시로 시간 복잡도 판단해보기
- 코드의 각 줄이 실행되는 것을 한 번의 연산이 수행된다고 생각하고 계산하면 된다.

### 최댓값 찾기 - 방법#1
```python
def find_max_num1(array):
	for number in array:                   # array의 길이 N만큼 연산 실행
		for compare_number in array:       # array의 길이 N만큼 연산 실행
			if number < compare_number:    # 비교 연산 1회 실행
				is_max_num = False         # 대입 연산 1회 실행
		if is_max_num:                     # 비교 연산 1회 실행
			return number
```
- 주석의 연산들을 더해보면,
  `array의 길이 X array의 길이 X (비교 연산 1회 + 대입 연산 1 + 비교 연산 1)` 로 표현 가능하다.
- 시간복잡도를 계산할 때, array의 길이를 보통 N으로 표시한다. 이를 적용하여 다시 작성해보면,
  `N X N X (1 + 1 + 1) = 3N^2` 로 표현 가능하다.

### 최댓값 찾기 - 방법#2
```python
def find_max_num(array):
	max_num = 0                # 대입 연산 1회 실행
	for i in array:            # array의 길이 N만큼 연산 실행
		if i >= max_num:       # 비교 연산 1회 실행
			max_num = i        # 대입 연산 1회 실행
	return max_num
```
- 주석의 연산들을 다시 표현해보면, `1 + N X (1 + 1) = 1 + 2N`이 된다.

### 시간 복잡도 비교
- 방법1 시간 복잡도 : `3N^2`
- 방법2 시간 복잡도 : `1 + 2N`
- N이 커져도 방법2의 시간 복잡도는 방법 1보다 적게 커지니,  방법2의 시간 복잡도가 더 좋다.\
- N이 커질수록 두 방법 간 시간 복잡도의 차이는 어마어마하게 커진다.
	- 이러한 차이를 내는 것은 N(변수)의 지수이다. 그 외의 상수는 유의미한 차이를 만들지 않는다.
	- 시간 복잡도를 판단할 때, N의 지수를 위주로 빠르고 편리하게 판단하자.



  
