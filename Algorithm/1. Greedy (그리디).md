---
Index: "[[🏷 Lecture Notes]]"
source_url: https://www.youtube.com/watch?v=2zjoKjt97vQ&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=2
tags:
  - "#Python"
  - "#CodingTest"
  - "#Algorithm"
  - "#Greedy"
status: Done
---
### 개요

- **그리디 알고리즘(탐욕법)** 은 **현재 상황에서 지금 당장 좋은 것만 고르는 방법**을 의미한다.,
- 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.
- 그리디 해법은 그 정당성 분석이 중요하다.
	- 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토해야 한다.
- 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다.
	- 하지만 코테에서 대부분의 그리디 문제는 **탐욕법으로 얻은 해가 최적의 해가 되는 상황**에서,
	  이를 추론할 수 있어야 풀리도록 출제된다.

### 예제) 거스름돈

- 문제
	- 당신은 음식점의 계산을 도와주는 점원이다. 
	- 당신은 500원, 100원, 50원, 10원 짜리 동전을 무한히 보유하고 있다.
	- 거슬러줘야할 돈이 N원일 때, 거슬러줘야할 동전의 최소 개수를 구하라.
	- 단 거슬러줘야할 돈은 항상 10의 배수제이다.

- 문제 해설
	- '가장 큰 화폐 단위부터' 돈을 거슬러 주는 것이 핵심 아이디어이다.
	- 가장 먼저, 500원으로 최대한 거슬러 준다.,
	- 그 다음 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을만큼 거슬러 주면
	  최소 개수의 동전으로 거슬러 줄 수 있다.

- 그리디 알고리즘의 정당성
	- 그리디 알고리즘으로 문제 해법을 찾았을 때는 그 해법이 정당한지 검토해야 한다.
	- 거스름 문제를 그리디 알고리즘으로 해결할 수 있는 이유
		- ==가지고 있는 동적 중에서 큰 단위가 항상 작은 단위의 배수이므로, 작은 단위 동전들을 종합해 다른 해가 나올 수 없기 떄문이다.==
			- 예를 들어, 800원을 거슬러줘야 하는데, 500, 400, 100원을 가지고 있는 경우
				- 그리디 방법으로는 500 * 1, 100 * 3 으로 총 4개가 최소 개수이다.
				- 하지만, 400원을 사용하면, 동전 2개로 거슬러 줄 수 있다.
		- 즉, 이 문제에서 큰 단위가 작은 단위의 배수 형태이므로,
		  '가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 작업만을 수행하면 된다'는 아이이디어 정당할 수 있다.

```python
# 거슬러줘야 할 돈 : 1,260
# 500원 -> 100원 -> 50원 -> 10원

n = 1260
count = 0

coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n // coin
    n %= coin

print(count)

---

6
```


### 문제) 1일 될 때까지
- 어떠한 수 N이 1일 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.
- 단, 두 번째 연산은 N이 K로 나누어 떨어질 떄만 선택할 수 있다.
	- 1) N에서 1을 뺀다.
	- 2) N을 K로 나눈다.
- 예를 들어, N이 17, K가 4라고 가정
  이때 1번의 과정을 한 번 수행하면 N은 16이 된다.
  이후에 2번의 과정을 두 번 수행하면 N은 1이 된다.
  결과적으로 이 경우 전체 과정을 실행한 수는 3이 된다. 이는 N을 1로 만드는 최소 횟수이다.
- N과 K가 주어질 때, N이 1이 될 때까지 1 또는 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성

- 그리디 검증
	- 가능하면 최대한 많이 나누는 작업이 최적의 해를 항상 보장할 수 있는가?
	- N이 아무리 큰 수여도, K로 계속 나누면 기하급수적으로 줄일 수 있다.
	- 즉, K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있다.
		- 또한 N은 항상 1에 도달한다.


- 단순하게 푸는 방법
```python
# 1이 될 때까지
# 단순하게 푸는 방법

n, k = map(int, input().split())
result = 0

while n >= k:
    while n % k != 0:
        n -= 1
        result += 1
    n //= k
    result += 1

while n > 1:
    n -= 1
    result += 1

print(result)
```

- 시간 복잡도를 줄일 수 있도록 푸는 방법
```python
# N이 1이 될 때까지
# 1. N - 1
# 2. N / K (N이 K로 나누어 떨어지는 경우, N % K == 0)

# K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있다.

# N, K를 공백으로 구분하여 입력받기
n, k = map(int, input().split())

result = 0

while True:
    # (N이 K로 나누어 떨어지는 수)가 될 때까지 1씩 빼기
    target = (n // k) * k
    result += (n - target)
    n = target

    # N이 K보다 작을 때(더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break

    # K로 나누기
    result += 1
    n //= k

# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)
```


### 문제) 곱하기 혹은 더하기
- 각 자리가 숫자(0~9)로만 이루어진 문자열 S가 주어졌을 때,
  왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'X' 혹은 '+' 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰수를 구하는 프로그램을 작성
- 단, + 보다 X 를 먼저 계산하는 방식과 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정한다.
- 예를 들어,
  02984라는 문자열로 만들 수 있는 가장 큰 수는 ((((0 + 2) X 9) X 8) X 4) = 576입니다.
  또한 만들어질 수 있는 가장 큰 수는 20억 이하의 정수가 되도록 입력이 주어집니다.

- 문제 해결 아이디어
	- 0, 1은 더하고 나머지는 전부 곱하면 가장 큰 수가 만들어질 것이다.
		- 대부분의 경우 + 보다는 X가 값을 더 크게 만든다.
		- 다만 두 수 중에 하나라도 0 또는 1일 경우, 곱하기보다 더하기를 수행하는 것이 수를 더 크게 만들 수 있다.
		- 따라서, 두 수에 대하여 연산을 수행할 때,
		  두 수 중에 하나라도 1 이하인 경우는 더하고
		  두 수가 모두 2 이상인 경우에는 곱하면 정답이다.

```python
# 곱하기 혹은 더하기
# 아이디어 : 두 수 중에 하나라도 1 이하인 경우는 더하고, 두 수 모두 2 이상인 경우 곱한다.

data = input()

# 첫 번째 문자를 숫자로 변경하여 대입
result = int(data[0])

for i in range(1, len(data)):
    # 두 수 중에서 하나라도 0 혹은 1인 경우, 곱하기 보다는 더하기 수행
    num = int(data[i])
    if num <= 1 or result <=1:
        result += num
    else:
        result *= num

print(result)
```


### 문제) 모험가 길드
- 한 마을에 모함가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 '공포도'를 측정했는데, 공포도가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다.
- 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성된 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다.
- 동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다.
  N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹의 최댓값을 구하는 프로그램을 작성
- 예를 들어, N = 5 이고, 각 모험가의 공포도가 '2 3 1 2 2' 인 경우
	- 그룹 1에 공포도가 1, 2, 3인 모험가를 한 명씩 넣고, 그룹 2에 공포도가 2인 남은 두명을 넣게 되면 총 2개의 그룹을 만들 수 있습니다.
	- 또한 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정 그룹에 넣을 필요는 없습니다.

```python
# 모험가 길드
## 공포도가 X인 모험가는 반드시 X명 이상으로 구성된 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했습니다.
## 동빈이는 최대 몇 개의 모험가 그룹을 만들 수 있는지 궁금합니다.
## N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹의 최댓값을 구하는 프로그램을 작성


n = int(input())
data = list(map(int, input().split()))
data.sort()

result = 0    # 총 그룹의 수
count = 0     # 현재 그룹에 포함된 모험가의 수

for i in data:        # 공포도를 낮은 것부터 하나씩 확인하며
    count += 1        # 현재 그룹에 해당 모험가를 포함시키기
    if count >= i:    # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면, 그룹 결성
        result += 1   # 총 그룹의 수 증가 시키기
        count = 0     # 현재 그룹에 포함된 모험가의 수 초기화

print(result)

---

5
2 3 1 2 2
2
```




### 문제) 큰 수의 법칙

큰 수의 법칙
- 다양한 수로 이루어진 배열에서,
- 주어진 수들을 M번 더해서 가장 큰 수를 만드는 법칙
- 단, 배열의 특정 인덱스에 해당하는 수가 연속으로 K번을 초과하여 더해질 수 없다.

예시1)
2, 4, 5, 4, 6,
M = 8, K = 3
=> 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5

예시2) 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
3, 4, 3, 4, 3
M = 7, K = 2
=> 4 + 4 + 4 + 4 + 4 + 4 + 4

```python
# 배열의 크기 N
# 숫자가 더해지는 횟수 M
# 더하기 제한 수 K

# N, M, K를 공백으로 구분해서 입력받기
n, m, k = map(int, input().split())
# N 개의 수를 공백으로 구분해서 입력받기
data = list(map(int, input().split()))

data.sort()        # 입력 받은 수들 정렬(오름차순)
first = data[-1]   # 가장 큰 수
second = data[-2]  # 두번째로 큰 수

result = 0

while True:
    for i in range(k):   # 가장 큰 수를 K번 더하기
        if m == 0:       # m이 0이라면 반복문 탈출
            break
        result += first
        m -= 1           # 더할 때마다 1씩 빼기
    if m == 0:           # m이 0이라면 반복문 탈출
      break
    result += second     # 두 번째로 큰 수를 한 번 더하기
    m -= 1               # 더할 때마다 1씩 빼기

print(result)
```